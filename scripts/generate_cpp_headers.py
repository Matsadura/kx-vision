"""
C++ Header Generator for GW2 API Data
Part of the kx-vision project: https://github.com/kxtools/kx-vision

Generates C++ header files from cached GW2 API data.
"""

import json
import time
import os
import logging
import re

# Setup simple logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Configuration
ENDPOINTS_TO_PROCESS = [
    {'name': 'ITEM', 'cache_file': 'ITEM_data.json'},
    {'name': 'STAT', 'cache_file': 'STAT_data.json'},
]
CACHE_DIR = "api_cache"
OUTPUT_DIR = "../src/Game/Generated"

def sanitize_cpp_string(value):
    """Properly sanitize strings for C++ code generation."""
    if not isinstance(value, str):
        value = str(value)
    
    # Comprehensive escaping for C++ strings
    value = value.replace("\\", "\\\\")  # Backslashes first
    value = value.replace('"', '\\"')    # Double quotes
    value = value.replace('\n', '\\n')   # Newlines
    value = value.replace('\r', '\\r')   # Carriage returns
    value = value.replace('\t', '\\t')   # Tabs
    
    # Remove non-printable characters except common ones
    value = re.sub(r'[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x9F]', '', value)
    
    return value

def sanitize_cpp_identifier(value):
    """Create valid C++ identifier from string."""
    if not isinstance(value, str):
        value = str(value)
    
    # Replace invalid characters with underscores
    value = re.sub(r'[^a-zA-Z0-9_]', '_', value)
    
    # Ensure it starts with a letter or underscore
    if value and value[0].isdigit():
        value = f"_{value}"
    
    # Ensure it's not empty
    if not value:
        value = "Unknown"
    
    return value

def validate_loaded_data(loaded_data):
    """Validate the structure of loaded data."""
    for endpoint_name, data in loaded_data.items():
        if not isinstance(data, list):
            raise ValueError(f"Expected list for {endpoint_name}, got {type(data).__name__}")
        
        if not data:
            logger.warning(f"No data found for {endpoint_name}")
            continue
        
        # Check required fields
        required_fields = {'ITEM': ['id', 'name'], 'STAT': ['id', 'name']}
        for item in data[:5]:  # Check first 5 items
            if not isinstance(item, dict):
                raise ValueError(f"Invalid item structure in {endpoint_name}")
            
            for field in required_fields.get(endpoint_name, []):
                if field not in item:
                    raise ValueError(f"Missing required field '{field}' in {endpoint_name}")

def get_file_header():
    """Generate consistent file header."""
    return f"""// This file is automatically generated by generate_cpp_headers.py. DO NOT EDIT.
// Generated on: {time.ctime()}
//
// Licensed under the same terms as the kx-vision project:
// https://github.com/kxtools/kx-vision
//
// MIT License
"""

def generate_cpp_files(fetched_data):
    """Generate C++ header files from fetched data."""
    logger.info("Generating C++ header files from cached data...")
    
    try:
        os.makedirs(OUTPUT_DIR, exist_ok=True)
    except OSError as e:
        logger.error(f"Failed to create output directory {OUTPUT_DIR}: {e}")
        return False

    # Extract and sanitize enum values
    try:
        all_rarities = sorted(list(set(
            sanitize_cpp_identifier(item.get('rarity', 'Unknown')) 
            for item in fetched_data.get('ITEM', []) 
            if item.get('rarity')
        )))
        
        all_item_types = sorted(list(set(
            sanitize_cpp_identifier(item.get('type', 'Unknown')) 
            for item in fetched_data.get('ITEM', []) 
            if item.get('type')
        )))
        
        all_attributes = sorted(list(set(
            sanitize_cpp_identifier(attr.get('attribute', 'Unknown')) 
            for stat in fetched_data.get('STAT', []) 
            for attr in stat.get('attributes', []) 
            if attr.get('attribute')
        )))
        
        # Ensure we have at least 'Unknown' values
        if not all_rarities:
            all_rarities = ['Unknown']
        if not all_item_types:
            all_item_types = ['Unknown']
        if not all_attributes:
            all_attributes = ['Unknown']
            
    except Exception as e:
        logger.error(f"Failed to extract enum values: {e}")
        return False

    # Generate EnumsAndStructs.h
    try:
        enums_path = os.path.join(OUTPUT_DIR, "EnumsAndStructs.h")
        with open(enums_path, "w", encoding="utf-8") as f:
            logger.info("Generating EnumsAndStructs.h")
            f.write(get_file_header() + "\n\n")
            f.write("#ifndef KX_API_ENUMS_STRUCTS_H\n#define KX_API_ENUMS_STRUCTS_H\n\n")
            f.write("#include <cstdint>\n#include <vector>\n\n")
            f.write("namespace kx::data {\n\n")
            f.write(f"    enum class ApiRarity {{ {', '.join(all_rarities)} }};\n")
            f.write(f"    enum class ApiItemType {{ {', '.join(all_item_types)} }};\n")
            f.write(f"    enum class ApiAttribute {{ {', '.join(all_attributes)} }};\n\n")
            f.write("    struct StatAttribute { ApiAttribute attribute; };\n")
            f.write("    struct StatData { const char* name; std::vector<StatAttribute> attributes; };\n")
            f.write("    struct ItemData { const char* name; ApiRarity rarity; ApiItemType type; };\n\n")
            f.write("} // namespace kx::data\n\n#endif // KX_API_ENUMS_STRUCTS_H\n")
    except IOError as e:
        logger.error(f"Failed to write EnumsAndStructs.h: {e}")
        return False

    # Generate ItemData.h
    try:
        items_path = os.path.join(OUTPUT_DIR, "ItemData.h")
        with open(items_path, "w", encoding="utf-8") as f:
            logger.info("Generating ItemData.h")
            f.write(get_file_header() + "\n\n")
            f.write("#ifndef KX_ITEM_DATA_H\n#define KX_ITEM_DATA_H\n\n")
            f.write('#include "EnumsAndStructs.h"\n#include <unordered_map>\n\n')
            f.write("namespace kx::data::item {\n\n")
            f.write("    inline const std::unordered_map<uint32_t, ItemData> DATA = {\n")
            
            item_count = 0
            for item in fetched_data.get('ITEM', []):
                try:
                    if not item.get('id') or not item.get('name'):
                        continue
                        
                    name = sanitize_cpp_string(item.get("name", ""))
                    rarity = sanitize_cpp_identifier(item.get('rarity', 'Unknown'))
                    item_type = sanitize_cpp_identifier(item.get('type', 'Unknown'))
                    
                    f.write(f'        {{ {item["id"]}, {{"{name}", '
                           f'kx::data::ApiRarity::{rarity}, '
                           f'kx::data::ApiItemType::{item_type}}} }},\n')
                    item_count += 1
                    
                except Exception as e:
                    logger.warning(f"Skipping invalid item {item.get('id', 'unknown')}: {e}")
                    continue
            
            f.write("    };\n\n} // namespace kx::data::item\n\n#endif // KX_ITEM_DATA_H\n")
            logger.info(f"Generated {item_count} item entries")
            
    except IOError as e:
        logger.error(f"Failed to write ItemData.h: {e}")
        return False

    # Generate StatData.h
    try:
        stats_path = os.path.join(OUTPUT_DIR, "StatData.h")
        with open(stats_path, "w", encoding="utf-8") as f:
            logger.info("Generating StatData.h")
            f.write(get_file_header() + "\n\n")
            f.write("#ifndef KX_STAT_DATA_H\n#define KX_STAT_DATA_H\n\n")
            f.write('#include "EnumsAndStructs.h"\n#include <unordered_map>\n\n')
            f.write("namespace kx::data::stat {\n\n")
            f.write("    inline const std::unordered_map<uint32_t, StatData> DATA = {\n")
            
            stat_count = 0
            for stat in fetched_data.get('STAT', []):
                try:
                    if not stat.get('id') or not stat.get('name'):
                        continue
                        
                    name = sanitize_cpp_string(stat.get("name", ""))
                    f.write(f'        {{ {stat["id"]}, {{"{name}", {{')
                    
                    attributes = []
                    for attr in stat.get("attributes", []):
                        attr_name = attr.get("attribute")
                        if attr_name:
                            sanitized_attr = sanitize_cpp_identifier(attr_name)
                            attributes.append(f"{{kx::data::ApiAttribute::{sanitized_attr}}}")
                    
                    f.write(", ".join(attributes))
                    f.write("}} },\n")  # ‚Üê Fixed: removed extra brace
                    stat_count += 1
                    
                except Exception as e:
                    logger.warning(f"Skipping invalid stat {stat.get('id', 'unknown')}: {e}")
                    continue
            
            f.write("    };\n\n} // namespace kx::data::stat\n\n#endif // KX_STAT_DATA_H\n")
            logger.info(f"Generated {stat_count} stat entries")
            
    except IOError as e:
        logger.error(f"Failed to write StatData.h: {e}")
        return False

    # Generate main include file
    try:
        main_path = os.path.join(OUTPUT_DIR, "APIData.h")
        with open(main_path, "w", encoding="utf-8") as f:
            logger.info("Generating APIData.h")
            f.write(get_file_header() + "\n\n")
            f.write("#ifndef KX_API_DATA_H\n#define KX_API_DATA_H\n\n")
            f.write("// This is a convenience header to include all generated API data files.\n\n")
            f.write('#include "EnumsAndStructs.h"\n')
            for endpoint in ENDPOINTS_TO_PROCESS:
                f.write(f'#include "{endpoint["name"].capitalize()}Data.h"\n')
            f.write("\n#endif // KX_API_DATA_H\n")
    except IOError as e:
        logger.error(f"Failed to write APIData.h: {e}")
        return False

    return True

if __name__ == "__main__":
    logger.info("Starting C++ header generator...")
    
    loaded_data = {}
    
    for endpoint in ENDPOINTS_TO_PROCESS:
        cache_path = os.path.join(CACHE_DIR, endpoint['cache_file'])
        
        try:
            logger.info(f"Loading cached data from: {cache_path}")
            with open(cache_path, "r", encoding="utf-8") as f:
                loaded_data[endpoint['name']] = json.load(f)
            logger.info(f"Successfully loaded {len(loaded_data[endpoint['name']])} entries")
            
        except FileNotFoundError:
            logger.error(f"Cache file not found: {cache_path}")
            logger.error("Please run 'fetch_api_data.py' first")
            exit(1)
        except (json.JSONDecodeError, IOError) as e:
            logger.error(f"Failed to load/parse {cache_path}: {e}")
            exit(1)
    
    try:
        validate_loaded_data(loaded_data)
        
        if generate_cpp_files(loaded_data):
            logger.info("Script completed successfully!")
        else:
            logger.error("Script failed during file generation")
            exit(1)
            
    except Exception as e:
        logger.error(f"Script failed: {e}")
        exit(1)